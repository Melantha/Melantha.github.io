<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Melantha</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-25T07:16:19.279Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Melantha</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>try catch捕获异常</title>
    <link href="http://yoursite.com/2019/03/25/try%20catch%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8/"/>
    <id>http://yoursite.com/2019/03/25/try catch捕获异常/</id>
    <published>2019-03-25T07:16:15.907Z</published>
    <updated>2019-03-25T07:16:19.279Z</updated>
    
    <content type="html"><![CDATA[<p>try/catch主要用于捕获异常，只能捕获“同步代码”中的”运行时异常”<br> <a id="more"></a></p><h3 id="try-catch主要用于捕获异常，try-catch语句包含了yigebtry块，和至少有一个catch块或者饿一个finally块，有如下三种tyr声明："><a href="#try-catch主要用于捕获异常，try-catch语句包含了yigebtry块，和至少有一个catch块或者饿一个finally块，有如下三种tyr声明：" class="headerlink" title="try/catch主要用于捕获异常，try/catch语句包含了yigebtry块，和至少有一个catch块或者饿一个finally块，有如下三种tyr声明："></a>try/catch主要用于捕获异常，try/catch语句包含了yigebtry块，和至少有一个catch块或者饿一个finally块，有如下三种tyr声明：</h3><ul><li>try…catch</li><li>try…finally</li><li>try…catch…finally<br><code>try</code>中放入可能会产生异常的语句或函数<br><code>catch</code>块中包含要执行的语句，当<code>try</code>中抛出异常时，<code>catch</code>块会捕获这个异常信息，并执行<code>catch</code>块中的代码，如果在try中没有异常抛出，catch块将会跳过。</li></ul><p><code>finally</code>在 <code>try</code>块和<code>catch</code>块之后执行，无论是否有异常抛出或者是否被捕获它总是执行。当在<code>finally</code>中抛出异常信息时会覆盖<code>try</code>中的异常信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    tryCode - 尝试执行代码块</span><br><span class="line">&#125;</span><br><span class="line">catch(err) &#123;</span><br><span class="line">    catchCode - 捕获错误的代码块</span><br><span class="line">&#125; </span><br><span class="line">finally &#123;</span><br><span class="line">    finallyCode - 无论 try / catch 结果如何都会执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>try…catch是同步代码，只能捕获“同步代码”中的”运行时异常”，”同步代码”是无法获取如setTimeout、Promise等异步代码的异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> try &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">     console.log(2);</span><br><span class="line">     throw new Error(&quot;This is a test error 2&quot;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  console.log(3);</span><br><span class="line">  &#125; catch(err) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"> console.log(4);</span><br><span class="line">// 执行结果为：1、3、4、2</span><br></pre></td></tr></table></figure></p></blockquote><p>假如 try {} catch(err) {} 这部分代码为函数f1,setTimeOut里面定义的异步函数，要在f1执行完之后才会执行，所以f1里面的catch是抓不到错误。<br>try … catch 作为同步代码的异常捕获语句，是在阶段 1 执行的。异步的错误，发生阶段 2，由此可知：已经执行完毕的 try … catch 不可能捕获到在它执行完毕后所发生的错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;try/catch主要用于捕获异常，只能捕获“同步代码”中的”运行时异常”&lt;br&gt;
    
    </summary>
    
      <category term="Js" scheme="http://yoursite.com/categories/Js/"/>
    
    
      <category term="Js" scheme="http://yoursite.com/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>HTTP常用状态码</title>
    <link href="http://yoursite.com/2018/09/28/HTTP%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://yoursite.com/2018/09/28/HTTP常用的状态码/</id>
    <published>2018-09-28T13:20:41.000Z</published>
    <updated>2018-09-28T13:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp; 当访问一个网页时，浏览器会向网页所在的服务器发出请求。当浏览器接收并显示网页前，网页所在服务器会返回一个包含HTTP状态码的信息头，用以响应浏览器的请求。<br>&emsp;&emsp; 本文整理了常见的HTTP状态码（表示网页服务器HTTP响应状态的3位数字代码，第一个十进制表示分类，后两个数字没有分类的作用。HTTP状态码共分为5种类型），如有错误请指正。<br> <a id="more"></a></p><h4 id="1xx-信息状态码："><a href="#1xx-信息状态码：" class="headerlink" title="1xx 信息状态码："></a>1xx 信息状态码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100：继续</span><br><span class="line">101：切换协议</span><br></pre></td></tr></table></figure><h4 id="2xx-成功状态码"><a href="#2xx-成功状态码" class="headerlink" title="2xx 成功状态码"></a>2xx 成功状态码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">200：ok 服务器已成功处理请求</span><br><span class="line">202：已接受请求，但处理尚未完成</span><br><span class="line">204：无内容，在没有新文档情况下，确保浏览器继续显示当前文档</span><br><span class="line">206：客户端发送了一个带有Range的GET请求头，服务器完成了它。</span><br></pre></td></tr></table></figure><h3 id="3xx-重定向-每次请求中使用重定向不要超过5次）"><a href="#3xx-重定向-每次请求中使用重定向不要超过5次）" class="headerlink" title="3xx 重定向 (每次请求中使用重定向不要超过5次）"></a>3xx 重定向 (每次请求中使用重定向不要超过5次）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">301：请求的资源已永久移动到新位置，文档新的URL会在定位响应头信息中给出，浏览器会自动连接到新的URL</span><br><span class="line">302：临时重定向，请求的网页临时移动到新位置，搜索引擎中保存原来的URL</span><br><span class="line">303：临时重定向，且总是使用Get请求新的URL</span><br><span class="line">304：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。用304代码告诉搜索引擎，可节省宽带和开销</span><br></pre></td></tr></table></figure><h3 id="4xx-客户端错误，请求可能出错，妨碍了服务器的处理"><a href="#4xx-客户端错误，请求可能出错，妨碍了服务器的处理" class="headerlink" title="4xx 客户端错误，请求可能出错，妨碍了服务器的处理"></a>4xx 客户端错误，请求可能出错，妨碍了服务器的处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">400：客户端请求语法有误，不能被服务器所理解。</span><br><span class="line">401：当前请求需要用户验证。</span><br><span class="line">403：服务器拒绝请求，请求被禁止。</span><br><span class="line">404：请求失败，服务器找不到请求的网页。</span><br><span class="line">410：请求的资源永久删除后，服务器返回此响应。</span><br></pre></td></tr></table></figure><h3 id="5xx-服务器在处理请求时发生错误"><a href="#5xx-服务器在处理请求时发生错误" class="headerlink" title="5xx 服务器在处理请求时发生错误"></a>5xx 服务器在处理请求时发生错误</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">500：服务器遇到错误，无法完成请求。（一般是会在服务器端的源代码出现错误时出现），原来缓冲的文档还可以继续使用。</span><br><span class="line">501：服务器不支持当前请求所需要的某个功能。</span><br><span class="line">502：（错误的网关）代理使用的服务器遇到了上游的无效响应</span><br><span class="line">503：（未提供此服务）：服务器由于维护或者负载过重未能应答，该情况是临时的。服务器宕机，请求未完成。</span><br><span class="line">505：服务器不支持请求中所指明的HTTP版本。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp; 当访问一个网页时，浏览器会向网页所在的服务器发出请求。当浏览器接收并显示网页前，网页所在服务器会返回一个包含HTTP状态码的信息头，用以响应浏览器的请求。&lt;br&gt;&amp;emsp;&amp;emsp; 本文整理了常见的HTTP状态码（表示网页服务器HTTP响应状态的3位数字代码，第一个十进制表示分类，后两个数字没有分类的作用。HTTP状态码共分为5种类型），如有错误请指正。&lt;br&gt;
    
    </summary>
    
      <category term="网络协议" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="网络协议" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>ES6常用新特性</title>
    <link href="http://yoursite.com/2018/09/25/ES6%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/25/ES6常见用法/</id>
    <published>2018-09-25T13:49:08.000Z</published>
    <updated>2018-09-25T13:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp; ES6无疑给前端带来了福音，它包含了很多很棒的新特性，可以更加方便的实现很多复杂的操作，提升开发效率。它包括了箭头函数、块级作用域、模板字符串、展开运算符、类、模块化、解构等。<br> <a id="more"></a></p><h3 id="ES6是什么？"><a href="#ES6是什么？" class="headerlink" title="ES6是什么？"></a>ES6是什么？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 新的Javascript语法标准 (<span class="number">2015</span>年<span class="number">6</span>月正式发布）</span><br><span class="line"></span><br><span class="line">- 使用babel语法转换器，支持低端浏览器</span><br><span class="line"></span><br><span class="line">- 流行的库都基于ES6构建，React默认使用ES6新语法开发</span><br></pre></td></tr></table></figure> <!-- more --><blockquote><h3 id="ES6有什么？"><a href="#ES6有什么？" class="headerlink" title="ES6有什么？"></a>ES6有什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 块级作用域、字符串、函数</span><br><span class="line">- 对象扩展、结构</span><br><span class="line">- 类、模块化</span><br></pre></td></tr></table></figure></blockquote><h4 id="1-作用域：let和const："><a href="#1-作用域：let和const：" class="headerlink" title="1. 作用域：let和const："></a>1. 作用域：let和const：</h4><blockquote><p>函数作用域和全局作用域(ES5中的作用域）</p><ul><li>定义变量使用let替代vra</li><li>const定义不可以修改的变量（常量）</li><li>作用域和{}</li></ul></blockquote><h4 id="2-模板字符串："><a href="#2-模板字符串：" class="headerlink" title="2. 模板字符串："></a>2. 模板字符串：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'nianchen'</span>;</span><br><span class="line">course = <span class="string">'React开发'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>, + name + <span class="string">'课程是'</span> + course);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`hello,<span class="subst">$&#123;name&#125;</span>,课程是<span class="subst">$&#123;course&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    进行多行间距空行</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure><h4 id="3-函数扩展："><a href="#3-函数扩展：" class="headerlink" title="3. 函数扩展："></a>3. 函数扩展：</h4><ul><li>箭头函数: (简写代码，保持this作用域)<blockquote><p>箭头函数最直观的三个特点就是：</p></blockquote></li></ul><ol><li>不需要function关键字来创建函数；</li><li>省略return关键字</li><li>继承当前上下文的this关键字。<br>如下是一个ES5的方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var calculate = function(x, y, z) &#123;</span><br><span class="line">  if (typeof x != &apos;number&apos;) &#123; x = 0 &#125;</span><br><span class="line">  if (typeof y != &apos;number&apos;) &#123; y = 6 &#125;</span><br><span class="line"></span><br><span class="line">  var dwt = x % y</span><br><span class="line">  var result</span><br><span class="line"></span><br><span class="line">  if (dwt == z) &#123; result = true &#125;</span><br><span class="line">  if (dwt != z) &#123; result = false &#125;</span><br><span class="line">  </span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong> 使用ES6进行重构 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var calculate = function(x, y, z) &#123;</span><br><span class="line">    typeof x != &apos;number&apos; ? x = 0 : x = x;</span><br><span class="line">    typeof y != &apos;number&apos; ? y = 6 : y = y;</span><br><span class="line"></span><br><span class="line">    return x % y === z ? true : false;</span><br><span class="line">&#125;</span><br><span class="line">// 进阶使用方法：</span><br><span class="line">var calculate = function(x, y, z) &#123;</span><br><span class="line">    x = typeof x != &apos;number&apos; ? 0 : x ;</span><br><span class="line">    y = typeof y != &apos;number&apos; ? 6 : y;</span><br><span class="line"></span><br><span class="line">    return x % y === z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">hello(<span class="string">'nianchen'</span>)</span><br><span class="line"><span class="keyword">const</span> hello1 = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">hello1(<span class="string">'nianchen'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'niachen'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果函数体只有一条return语句：</span></span><br><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x*<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">5</span>));     <span class="comment">// 10;</span></span><br><span class="line">相当于下面的语句：</span><br><span class="line"><span class="keyword">const</span> double = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(double(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><ul><li>参数默认值；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="function">(<span class="params">name =<span class="string">'nianchen'</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">hello(<span class="string">'mo'</span>);  <span class="comment">// mo</span></span><br><span class="line">hello();  <span class="comment">// nianchen</span></span><br></pre></td></tr></table></figure><ul><li>展开运算符</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="function">(<span class="params">name1, name2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello, <span class="subst">$&#123;name1&#125;</span> 和 <span class="subst">$&#123;name2&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">oldHello</span>(<span class="params">name1, name2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name1, name2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'nianchen'</span>, <span class="string">'mo'</span>];</span><br><span class="line">oldHello.apply(<span class="literal">null</span>, arr);</span><br><span class="line">hello(...arr);</span><br></pre></td></tr></table></figure><h4 id="4-对象（Object）扩展："><a href="#4-对象（Object）扩展：" class="headerlink" title="4. 对象（Object）扩展："></a>4. 对象（Object）扩展：</h4><ul><li><p>Object.keys、values、entries</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">'nianchen'</span>, <span class="attr">course</span>: <span class="string">'react'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// ["name", "course"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">//  ["nianchen", "react"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); </span><br><span class="line"><span class="comment">// [ ['name', 'nianchen'], ['course', 'react'] ]</span></span><br></pre></td></tr></table></figure></li><li><p>对象方法简写，计算属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'xiamo'</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name,</span><br><span class="line">    [name]: <span class="string">'nianchen'</span>,</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    hello1 () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj[name] = <span class="string">'hello mo'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;name: 'xiamo', xiamo: ninachen, hello: f, hello1:f &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>展开运算符（不是ES6标准，但是babel也支持）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">name</span>: <span class="string">'nianchen'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;<span class="attr">course</span>: <span class="string">'react'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(...obj1,...obj2,<span class="attr">date</span>: <span class="string">'2018'</span>);</span><br><span class="line"><span class="comment">// &#123;name: 'nianchen', age: 18, course: 'react', date: '2018'&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-解构赋值"><a href="#5-解构赋值" class="headerlink" title="5. 解构赋值"></a>5. 解构赋值</h4><p>函数也可以多返回值了</p><ul><li>数组解构<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'nianchen'</span>, <span class="string">'xiamo'</span>];</span><br><span class="line"><span class="keyword">let</span> [arr1, arr2] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(arr1, <span class="string">'|'</span>, arr2);</span><br><span class="line"><span class="comment">// nianchen | xiamo</span></span><br><span class="line">- 对象解构</span><br><span class="line"><span class="keyword">const</span> obj =&#123;<span class="attr">name</span>: <span class="string">'nianchen'</span>, <span class="attr">course</span>: <span class="string">'react'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name, course&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, <span class="string">'|'</span>, course);</span><br><span class="line"><span class="comment">// nianchen | react</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-类"><a href="#6-类" class="headerlink" title="6. 类"></a>6. 类</h4><ul><li>是prototype的语法糖</li><li>Extends继承</li><li>Constructot构造函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">'nianchen'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> MyApp();</span><br><span class="line">app.sayHello();</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-新的数据结构"><a href="#7-新的数据结构" class="headerlink" title="7. 新的数据结构"></a>7. 新的数据结构</h4><ul><li>Set，元素不可重合</li><li>Map</li><li>Symbol</li></ul><h4 id="8-模块化"><a href="#8-模块化" class="headerlink" title="8. 模块化"></a>8. 模块化</h4><ul><li>Import, import{}</li><li>Export, Export default</li><li>Node现在还不支持，还需要require来加载文件</li><li>Promise</li><li>迭代器和生成器</li><li>代理Proxy</li></ul><h4 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9. Promise"></a>9. Promise</h4><p>   在JavaScript中，所有代码都是单线程执行的。在ES5中使用的是回调函数，可是过多回调函数会致使逻辑过于复杂，所以应景的出了ES6中的Promise，它最大的好处就是在异步执行流程中，把执行的代码和结果代码分离开如下图所示：<br>    <img src="/img/Js/promise_1.png" style="width: 380px; height: 200px"><br>    如果有多个异步任务，需要先做任务1，如果成功做任务2，任何失败则不再继续执行：<br>    <code>job1.then(job2).then(job3).catch(handleError);</code><br>    其中<code>job1</code>、<code>job2</code>和<code>job3</code>都是Promise对象。<br>    ** 1.  promise是一个构造函数，它的参数是（resolve和reject），resolve和reject分别是两个函数，这两个函数的作用是将promise的（pending 等待）转换为resolved（已解决），或者从pending转为rejected（已失败）。</p><pre><code>2. 它有then和catch方法，我们可以认为的在promise上添加一些满足我们自己需求的方法，方便每一个对象使用。** </code></pre><blockquote><p>Promise的方式虽然解决了callback，但是这种方式充满了Promise的then()方法，如果较为复杂的流程，then中会有大量代码。<br>    ES7中也推出了async和await：（Asyn函数有以下四点)</p><pre><code>- 内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样- 更好的语义。async 和 await 相较于 * 和 yield 更加语义化- 更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）- 返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用</code></pre></blockquote><h4 id="10-常见的数组处理方法："><a href="#10-常见的数组处理方法：" class="headerlink" title="10. 常见的数组处理方法："></a>10. 常见的数组处理方法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//映射数组</span></span><br><span class="line">arr = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>].map(<span class="function"><span class="params">v</span> =&gt;</span> v*<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [6, 15, 24];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有元素是否通过测试</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].every(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">3</span>);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否有元素通过测试</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].some(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">3</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤数组</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].filter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 4, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找符合条件的元素</span></span><br><span class="line"><span class="keyword">const</span> arr = [&#123;<span class="attr">name</span>: <span class="string">'nianchen'</span>, <span class="attr">age</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'xiamo'</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUser</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> element.name == <span class="string">'nianchen'</span></span><br><span class="line">&#125;</span><br><span class="line">arr.find(getUser);</span><br><span class="line"></span><br><span class="line">arr.find(<span class="function"><span class="params">v</span> =&gt;</span> v.name === <span class="string">'nianchen'</span>);</span><br><span class="line"><span class="comment">// &#123;name: "nianchen", age: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找索引</span></span><br><span class="line">[<span class="string">'nianchen'</span>,<span class="string">'xiamo'</span>,<span class="string">'chen'</span>].indexOf(<span class="string">'chen'</span>);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接数组</span></span><br><span class="line">arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr2 = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">[...arr1,...arr2];</span><br><span class="line"><span class="comment">//  [1, 2, 3, 6, 7, 8]</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 数组去重</span></span><br><span class="line"> arr = [<span class="string">'nianchen'</span>, <span class="string">'xiamo'</span>, <span class="string">'chen'</span>,<span class="string">'chen'</span>];</span><br><span class="line"> <span class="built_in">console</span>.log(...new <span class="built_in">Set</span>(arr);</span><br></pre></td></tr></table></figure><h4 id="11-常见的对象处理方法："><a href="#11-常见的对象处理方法：" class="headerlink" title="11. 常见的对象处理方法："></a>11. 常见的对象处理方法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象的key</span></span><br><span class="line">Objcet.keys(&#123;<span class="attr">name</span>: <span class="string">'nianchen'</span>, <span class="attr">course</span>: <span class="string">'react'</span>&#125;);</span><br><span class="line"><span class="comment">// ["name", "course"];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象里数据的数量</span></span><br><span class="line"><span class="built_in">Object</span>.keys(&#123;<span class="attr">name</span>: <span class="string">'nianchen'</span>, <span class="attr">course</span>: <span class="string">'react'</span>&#125;).length</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="built_in">Object</span>.entries(&#123;<span class="attr">name</span>: <span class="string">'nianchen'</span>, <span class="attr">course</span>: <span class="string">'react'</span>&#125;);</span><br><span class="line"><span class="comment">//  [["name", "nianchen"],["course", "react"]];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// extends功能</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">'nianchen'</span>, <span class="attr">course</span>: <span class="string">'react'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> newObj = &#123;...obj, <span class="attr">job</span>: <span class="string">'IT'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">// &#123;name: "nianchen", course: "react", job: "IT", age: 18&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取列表的头和尾</span></span><br><span class="line"><span class="keyword">const</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> [last, ...initial] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].reverse();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp; ES6无疑给前端带来了福音，它包含了很多很棒的新特性，可以更加方便的实现很多复杂的操作，提升开发效率。它包括了箭头函数、块级作用域、模板字符串、展开运算符、类、模块化、解构等。&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Vuex特性</title>
    <link href="http://yoursite.com/2018/09/25/vuex%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2018/09/25/vuex的特性/</id>
    <published>2018-09-25T13:28:42.000Z</published>
    <updated>2018-09-25T13:28:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了vuex的几个核心概念：state、getter、mutation、action、moudle</p><a id="more"></a><h3 id="vuex有哪几种属性："><a href="#vuex有哪几种属性：" class="headerlink" title="vuex有哪几种属性："></a>vuex有哪几种属性：</h3><p>   有五种：state、getter、mutation、action、moudle</p><h4 id="1-state的特征："><a href="#1-state的特征：" class="headerlink" title="1. state的特征："></a>1. state的特征：</h4><ul><li>vuex就像一个数据库，里面可以存放很多对象。其中state就是数据源存放地，对于与一般Vue对象里的data。</li><li>state里存放的数据是响应式的，Vue组件从store中读取数据，若是从store中读取的数据发生改变，依赖这个数据的组件也会更新</li><li>它通过mapState把全局的state和getters映射到当前组件的computed计算属性中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters([</span><br><span class="line">    </span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-getter特性："><a href="#2-getter特性：" class="headerlink" title="2. getter特性："></a>2. getter特性：</h4><p>vuex的getters可以对state进行计算操作，它就是store的计算属性。getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><h4 id="3-mutations特性："><a href="#3-mutations特性：" class="headerlink" title="3. mutations特性："></a>3. mutations特性：</h4><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation，可在回调函数中修改store中的状态。</p><h4 id="4-action特性："><a href="#4-action特性：" class="headerlink" title="4. action特性："></a>4. action特性：</h4><p>Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。</p><h4 id="5-vue-js中的ajax请求代码应该在组件的methods中还是vuex得actions中？"><a href="#5-vue-js中的ajax请求代码应该在组件的methods中还是vuex得actions中？" class="headerlink" title="5. vue.js中的ajax请求代码应该在组件的methods中还是vuex得actions中？"></a>5. vue.js中的ajax请求代码应该在组件的methods中还是vuex得actions中？</h4><ol><li>如果请求得到的数据，不会被其他组件复用，那么就不需要放在state中。</li><li>如果ajax返回的数据会在多个地方都被调用，则需要把请求放在action中，方便复用，并包装为promise返回。在调用处使用async和await处理返回的数据。</li></ol><h4 id="6-moudle特性："><a href="#6-moudle特性：" class="headerlink" title="6.moudle特性："></a>6.moudle特性：</h4><p>当应用比较复杂时，store对象就会变得比较臃肿，此时将store分割成模块，让每个模块拥有自己的 state、mutation、action、getter</p><h4 id="7-不会使用vuex带来什么问题？"><a href="#7-不会使用vuex带来什么问题？" class="headerlink" title="7.不会使用vuex带来什么问题？"></a>7.不会使用vuex带来什么问题？</h4><ol><li>可维护性下降。</li><li>可读性下降。</li><li>增加耦合，大量的上传派发，会让耦合性大大的增加。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了vuex的几个核心概念：state、getter、mutation、action、moudle&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vuex" scheme="http://yoursite.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>css实现左边自适应右边固定</title>
    <link href="http://yoursite.com/2018/09/25/css%E5%AE%9E%E7%8E%B0%E5%B7%A6%E8%BE%B9%E8%87%AA%E9%80%82%E5%BA%94%E5%8F%B3%E8%BE%B9%E5%9B%BA%E5%AE%9A/"/>
    <id>http://yoursite.com/2018/09/25/css实现左边自适应右边固定/</id>
    <published>2018-09-25T10:06:09.000Z</published>
    <updated>2018-09-25T10:32:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要使用css实现左边自适应右边固定，右边固定左边自适应的问题。<br><img src="/img/CSS/left_right.png"><br><a id="more"></a></p><h2 id="左边自适应右边固定"><a href="#左边自适应右边固定" class="headerlink" title="左边自适应右边固定"></a>左边自适应右边固定</h2><h3 id="1-主要使用float和margin值"><a href="#1-主要使用float和margin值" class="headerlink" title="1.  主要使用float和margin值"></a>1.  主要使用float和margin值</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left_L1"</span>&gt;</span>左边固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right_L1"</span>&gt;</span>右边自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">100px</span>; <span class="attribute">margin-bottom</span>: <span class="number">20px</span>; &#125;</span><br><span class="line"><span class="selector-class">.left_L1</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>: green;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right_L1</span> &#123;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-主要使用position定位结合margin值"><a href="#2-主要使用position定位结合margin值" class="headerlink" title="2. 主要使用position定位结合margin值"></a>2. 主要使用position定位结合margin值</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap wrapL2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left_L2"</span>&gt;</span>左边固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right_L2"</span>&gt;</span>右边自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapL2</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left_L2</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right_L2</span> &#123;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右边固定左边自适应"><a href="#右边固定左边自适应" class="headerlink" title="右边固定左边自适应"></a>右边固定左边自适应</h2><h3 id="1-主要使用float和负的margin值"><a href="#1-主要使用float和负的margin值" class="headerlink" title="1.  主要使用float和负的margin值"></a>1.  主要使用float和负的margin值</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left_R1"</span>&gt;</span>左边自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right_R1"</span>&gt;</span>右边固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left_R1</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>: red;</span><br><span class="line"><span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right_R1</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>: green;</span><br><span class="line"><span class="attribute">float</span>: right;</span><br><span class="line"><span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-主要使用position定位结合负的margin值"><a href="#2-主要使用position定位结合负的margin值" class="headerlink" title="2. 主要使用position定位结合负的margin值"></a>2. 主要使用position定位结合负的margin值</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap wrapL2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left_R2"</span>&gt;</span>左边自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right_R2"</span>&gt;</span>右边固定<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapL2</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left_R2</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right_R2</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">background</span>: red;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要使用css实现左边自适应右边固定，右边固定左边自适应的问题。&lt;br&gt;&lt;img src=&quot;/img/CSS/left_right.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vue知识整理</title>
    <link href="http://yoursite.com/2018/09/25/Vue%E7%9A%84%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/25/Vue的知识整理/</id>
    <published>2018-09-25T06:30:20.000Z</published>
    <updated>2018-09-25T06:30:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了vue的一些常见知识点，vue的双向绑定原理、生命周期等。</p><a id="more"></a><h4 id="vue实现双向绑定的方法："><a href="#vue实现双向绑定的方法：" class="headerlink" title="vue实现双向绑定的方法："></a>vue实现双向绑定的方法：</h4><p><strong>1. v-model指令：（它只是一个语法糖，其实应该是如下：）</strong><br> 对象实现响应式：<br>     是在初始化的时候利用definePrototype的定义setter和getter过滤器，在进行组件模板编译时实现water的监听搜集依赖项，当数据发生变化时在set中通过调用dep.notify进行发布通知，实现视图的更新。</p><blockquote><p>vue.js采用数据劫持结合发布者-订阅式模式的方式，通过object.defineProperty()来劫持各个属性的setter和getter，在数据变动时监听数据，触发相应的监听回调。Object.defineProperty()：方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象，可以用来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input v-model=&quot;text&quot;&gt; 展开即如下：</span><br><span class="line">    &lt;input :value=&quot;text&quot; @input=&quot;e =&gt; text = e.target.value&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;input :value=&quot;text&quot; @input=&quot;textChange&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      text: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    textChange: function (e) &#123;</span><br><span class="line">      this.text = e.target.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>data必须是一个函数，eg：组件都是会被重复使用，此时需要保证每个组件间是独立的互不影响的，当每个组件引用的时候，就会有一个新实例创建，确保每个组件可以维护独立的实例</li></ol><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Vue的生命周期包括：开始创建、初始化数据、编译模板、挂载Dom（el）、渲染-&gt;更新-&gt;更新、销毁（卸载）<br><code>以下类型都是： function</code></p><ul><li>beforeCreate：  <code>实例初始化之后调用，初始化数据</code><br> 在实例初始化后之后调用，数据观测(data observer)和event/watcher事件配置之前被调用。初始化事件（init event， Vue内部初始化事件）之前被调用。可以在这加个loading事件，在加载实例时触发。</li><li><p>created： <code>实例创建完之后调用，还没开始挂载$el</code><br> 在实例已经创建完成之后被调用，实例已经完成以下配置：数据观测（data observer)，属性和方法的运算，event事件回调。挂载阶段还没开始， $el 属性不可见。初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用（此时需要调用nextTick）</p></li><li><p>beforeMount：<code>开始挂载$el元素，但是html页面还没渲染</code><br>在挂载开始之前被调用。相关的render函数首次被调用，此时实例已完成以下：编译模板，把data里面的数据和模板生成html，但是还没挂载到html页面上。</p></li><li>mounted：挂载元素获取到Dom节点。<code>元素挂载完成，html页面渲染完成</code><br> 在el被新创建的vm.$el替换，并挂载到实例上之后调用。用上面编译好的html内容替换el属性指向的DOM对象。此时模板已经渲染到html页面中。可发起Ajax请求。mounted只会被执行一次。</li><li>beforeUpdate：<br> 在数据更新之前被调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器。<blockquote><p>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</p></blockquote></li><li>updated：<br> 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态（最好通过计算属性和watch来更改），因为会引起无限循环。<blockquote><p>该钩子在服务器端渲染期间不被调用</p></blockquote></li><li>beforeDestory：<br> 在实例销毁之前被调用，实例仍然可用。</li><li>destoryed：<br> 在实例销毁只会调用。调用后，所有事件监听器移除，所有的自实例也会被销毁。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.$nextTick()的回调韩顺中，因为cretaed中的DOM还未进行任何的渲染，此时操作DOM无异于徒劳。与之对应的就是在mounted函数中，因为mounted中的所有DOM挂载和渲染都已完成。</span><br><span class="line">2. 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构，这个操作都应该放在Vue.netTick()中。</span><br></pre></td></tr></table></figure></li></ul><h4 id="vue中常用的属性会方法进行对比"><a href="#vue中常用的属性会方法进行对比" class="headerlink" title="vue中常用的属性会方法进行对比"></a>vue中常用的属性会方法进行对比</h4><ul><li>computed：{}<br>计算属性的结果会被缓存，当依赖的属性发生改变时会重新计算。</li><li>activated：<code>function</code>：<br>keep-alive组件被激活时调用。（会缓存不活动的组件）<br><code>例如在切换tab标签（组件）时，就会被创建一个实例，此时我们希望能够在第一次被创建时就会被缓存下来，因此我们可以使用&lt;keep-alive&gt;元素将其动态组件包裹起来。</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 失活的组件将会被缓存！--&gt;</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了vue的一些常见知识点，vue的双向绑定原理、生命周期等。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>css实现水平垂直居中的方法</title>
    <link href="http://yoursite.com/2018/09/23/css%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/09/23/css实现水平垂直居中的方法/</id>
    <published>2018-09-23T05:35:50.000Z</published>
    <updated>2018-09-23T05:35:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要针对子元素已知宽高和未知宽高的情况下，对其进行水平垂直居中<br> <a id="more"></a><br>&emsp;&emsp; 本文假设对如下元素进行水平垂直居中方式（父元素和子元素）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"children size"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>首先给他们加一个公共使用的样式（本文介绍的方法有定宽和不定宽的，所以size用来表示children的宽高）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.children</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: green;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.children</span> <span class="selector-class">.zise</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子元素相对父元素进行绝对定位，左和上边距为50%，此时子元素左上顶点在元素的正中间，只需要让子元素的中心点在父元素正中间即可：</p><h4 id="1-absolute-负margin"><a href="#1-absolute-负margin" class="headerlink" title="1. absolute + 负margin"></a>1. absolute + 负margin</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.children</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>次方法兼容性较好，只是只适用于必须知道子元素的宽高</li></ul><h4 id="2-absolute-margin-auto"><a href="#2-absolute-margin-auto" class="headerlink" title="2. absolute + margin auto"></a>2. absolute + margin auto</h4><p>通过设置各个方向距离都是0，然后再将margin设为auto<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.children</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>兼容性好，可是需要知道子元素的宽高</li></ul><h4 id="absolute-calc"><a href="#absolute-calc" class="headerlink" title="absolute + calc"></a>absolute + calc</h4><p>calc()属于CSS3，用于动态计算长度值。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.children</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="built_in">calc</span>(50% - 100px);</span><br><span class="line"><span class="attribute">left</span>: <span class="built_in">calc</span>(50% - 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>此方法属于css3，属于依赖于需要支持该语法才可以，且需要知道子元素宽高</li></ul><p>以下方法都是子元素未知的情况：</p><h4 id="4-absolute-transform-移动"><a href="#4-absolute-transform-移动" class="headerlink" title="4. absolute + transform 移动"></a>4. absolute + transform 移动</h4><p>使用css3新属性transform的translate, 其属性的百分比是相对于自身的宽和高进行移动。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.children</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>在一些浏览器中可能会出现模糊，是因为元素有可能被放置在办个像素的位置上，可通过以下方法解决此问题：<br><code>transform-style: preserve-3d;</code></p><ul><li>此方法需要依赖translate2d的兼容性，且不需要知道子元素宽高</li></ul></blockquote><h4 id="5-line-height-属性"><a href="#5-line-height-属性" class="headerlink" title="5. line-height 属性"></a>5. line-height 属性</h4><p>利用行内元素的属性实现居中：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">600px</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.children</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">line-height</span>: initial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>此时子元素文字居中显示<code>text-align: left; /* 修正文字 */</code></li></ul><h4 id="6-writing-mode"><a href="#6-writing-mode" class="headerlink" title="6. writing-mode"></a>6. writing-mode</h4><p>writing-mode可以改变文字的显示方向,比如可以通过writing-mode让文字的显示变为垂直方向:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="div1"&gt;水平方向&lt;/div&gt;</span><br><span class="line">&lt;div class="div2"&gt;垂直方向&lt;/div&gt;</span><br><span class="line"><span class="selector-class">.div2</span> &#123;</span><br><span class="line">    <span class="attribute">writing-mode</span>: vertical-lr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样可以改变文字的显示方向<br>具体实现方式如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wp-inner"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.wp &#123;</span><br><span class="line">    writing-mode: vertical-lr;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.wp-inner &#123;</span><br><span class="line">    writing-mode: horizontal-tb;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    text-align: center;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.box &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    margin: auto;</span><br><span class="line">    text-align: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="7-table"><a href="#7-table" class="headerlink" title="7. table"></a>7. table</h4><p>tabel单元格中的内容天然就是垂直居中的，只要添加一个水平居中属性就好了,table会增加代码的冗余性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"children"</span>&gt;</span>子元素-表格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.parent &#123;</span><br><span class="line">text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.children &#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>这种方法就是代码太冗余，而且也不是table的正确用法</li></ul><h4 id="8-css-table"><a href="#8-css-table" class="headerlink" title="8. css-table"></a>8. css-table</h4><p>css新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="9-flex"><a href="#9-flex" class="headerlink" title="9. flex"></a>9. flex</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>移动端已完全支持flex，PC端需要看浏览器的兼容性</li></ul><h4 id="10-grid"><a href="#10-grid" class="headerlink" title="10. grid"></a>10. grid</h4><p>css新出的网格布局，但是兼容性不好<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wp</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">    <span class="attribute">justify-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>该方法兼容性不如flex</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>PC端有兼容性要求，宽高固定，推荐absolute + margin auto</li><li>PC端有兼容要求，宽高不固定，推荐css-table</li><li>PC端无兼容性要求，推荐flex</li><li>移动端推荐使用flex</li></ul><p>注：本文主要参考此篇文章<a href="https://juejin.im/post/5b9a4477f265da0ad82bf921#comment" target="_blank" rel="noopener">CSS实现水平垂直居中的1010种方式（史上最全）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要针对子元素已知宽高和未知宽高的情况下，对其进行水平垂直居中&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>react生命周期</title>
    <link href="http://yoursite.com/2018/07/31/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2018/07/31/react生命周期/</id>
    <published>2018-07-31T08:52:12.000Z</published>
    <updated>2018-09-19T03:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Mounted：已插入真实 DOM （初始化）</li><li>Update：正在被重新渲染 （更新）</li><li>Unmounted：已移出真实 DOM （销毁）<a id="more"></a><h2 id="生命周期-创建-gt-消失"><a href="#生命周期-创建-gt-消失" class="headerlink" title="生命周期 (创建 -&gt; 消失)"></a>生命周期 (创建 -&gt; 消失)</h2><h5 id="1-Mounted-React-renderComponent"><a href="#1-Mounted-React-renderComponent" class="headerlink" title="1. Mounted: (React.renderComponent())"></a>1. Mounted: (React.renderComponent())</h5>&emsp;&emsp;React Components被render解析生成对应的DOM节点并被插入浏览器的DOM结构的一个过程 （即在浏览器上看到一个从无到有的相应的过程：mounted已经结束）；<h5 id="2-Update-当前state和最近一次的state进行对比，只有当state确实发生改变，并且影响了DOM结构的改变，react才会去改变。"><a href="#2-Update-当前state和最近一次的state进行对比，只有当state确实发生改变，并且影响了DOM结构的改变，react才会去改变。" class="headerlink" title="2.Update: 当前state和最近一次的state进行对比，只有当state确实发生改变，并且影响了DOM结构的改变，react才会去改变。"></a>2.Update: 当前state和最近一次的state进行对比，只有当state确实发生改变，并且影响了DOM结构的改变，react才会去改变。</h5>&emsp;&emsp;一个mounted的React Components被重新render的过程。<h5 id="3-Unmounted："><a href="#3-Unmounted：" class="headerlink" title="3.Unmounted："></a>3.Unmounted：</h5>&emsp;&emsp; 一个mounted的ReactComponents对应的DOM节点被从DOM结构中移除的这样一个过程。</li></ul><blockquote><p>每一个状态React都封装了一个hook（钩子）函数：<br>钩子函数就是指在所有函数执行前，我先执行了的函数，即 钩住 我感兴趣的函数，只要它执行，我就先执行。此概念（或者说现象）跟AOP（面向切面编程）很像。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;Mounted：已插入真实 DOM （初始化）&lt;/li&gt;
&lt;li&gt;Update：正在被重新渲染 （更新）&lt;/li&gt;
&lt;li&gt;Unmounted：已移出真实 DOM （销毁）
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
</feed>
